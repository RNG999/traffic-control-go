name: PR Validation

on:
  pull_request:
    types: [opened, edited, synchronize]

jobs:
  validate-issue-link:
    runs-on: ubuntu-latest
    name: Validate Issue Link
    steps:
      - name: Check for Issue Reference
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            
            console.log('=== PR VALIDATION DEBUG ===');
            console.log('PR Number:', prNumber);
            
            let hasValidIssueReference = false;
            let foundIssues = [];
            
            console.log('üîç Using GraphQL API for authoritative issue linking...');
            
            // GraphQL API„ÅßclosingIssuesReferences„ÇíÂèñÂæó
            async function checkGraphQLIssueReferences(maxRetries = 3, delayMs = 1000) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  console.log(`GraphQL API attempt ${attempt}/${maxRetries}`);
                  
                  const graphqlQuery = `
                    query($owner: String!, $repo: String!, $number: Int!) {
                      repository(owner: $owner, name: $repo) {
                        pullRequest(number: $number) {
                          number
                          title
                          closingIssuesReferences(first: 10) {
                            nodes {
                              number
                              title
                              url
                            }
                          }
                          timelineItems(itemTypes: [CROSS_REFERENCED_EVENT, CONNECTED_EVENT], first: 10) {
                            nodes {
                              __typename
                              ... on CrossReferencedEvent {
                                source {
                                  __typename
                                  ... on Issue {
                                    number
                                    title
                                  }
                                }
                              }
                              ... on ConnectedEvent {
                                subject {
                                  __typename
                                  ... on Issue {
                                    number
                                    title
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  `;
                  
                  const variables = {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    number: prNumber
                  };
                  
                  const response = await github.graphql(graphqlQuery, variables);
                  const pullRequest = response.repository.pullRequest;
                  
                  console.log('GraphQL PR data retrieved successfully');
                  console.log(`Closing issues: ${pullRequest.closingIssuesReferences.nodes.length}`);
                  console.log(`Timeline items: ${pullRequest.timelineItems.nodes.length}`);
                  
                  // closingIssuesReferences„Åã„ÇâËá™Âãï„ÇØ„É≠„Éº„Ç∫ÂØæË±°„ÅÆIssue„ÇíÂèñÂæó
                  const closingIssues = pullRequest.closingIssuesReferences.nodes.map(issue => issue.number);
                  foundIssues.push(...closingIssues);
                  
                  // Timeline„Åã„ÇâCross-referenced„Å™Issue„ÇÇÂèñÂæó
                  pullRequest.timelineItems.nodes.forEach(item => {
                    if (item.__typename === 'CrossReferencedEvent' && item.source?.__typename === 'Issue') {
                      const issueNumber = item.source.number;
                      if (!foundIssues.includes(issueNumber)) {
                        foundIssues.push(issueNumber);
                      }
                    } else if (item.__typename === 'ConnectedEvent' && item.subject?.__typename === 'Issue') {
                      const issueNumber = item.subject.number;
                      if (!foundIssues.includes(issueNumber)) {
                        foundIssues.push(issueNumber);
                      }
                    }
                  });
                  
                  if (closingIssues.length > 0) {
                    hasValidIssueReference = true;
                    console.log(`‚úÖ Found ${closingIssues.length} closing issue(s): ${closingIssues.map(n => '#' + n).join(', ')}`);
                    core.notice(`‚úÖ PR will auto-close issues: ${closingIssues.map(n => '#' + n).join(', ')}`);
                    return true;
                  }
                  
                  if (foundIssues.length > 0) {
                    hasValidIssueReference = true;
                    console.log(`‚úÖ Found ${foundIssues.length} referenced issue(s): ${foundIssues.map(n => '#' + n).join(', ')}`);
                    core.notice(`‚úÖ PR references issues: ${foundIssues.map(n => '#' + n).join(', ')}`);
                    return true;
                  }
                  
                  if (attempt < maxRetries) {
                    console.log(`‚è≥ No issue references found yet, waiting ${delayMs}ms before retry...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                  }
                  
                } catch (error) {
                  console.log(`‚ùå GraphQL API attempt ${attempt} failed:`, error.message);
                  if (attempt === maxRetries) {
                    throw error;
                  }
                  await new Promise(resolve => setTimeout(resolve, delayMs));
                }
              }
              return false;
            }
            
            try {
              const graphqlSuccess = await checkGraphQLIssueReferences();
              if (!graphqlSuccess) {
                console.log('‚ö†Ô∏è GraphQL API found no issue links, falling back to text parsing');
                // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „ÉÜ„Ç≠„Çπ„ÉàËß£Êûê
                const title = context.payload.pull_request.title;
                const body = context.payload.pull_request.body || '';
                
                console.log('PR Title:', title);
                console.log('PR Body length:', body.length);
                
                const patterns = [
                  /(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)\s+#\d+/gi,
                  /\B#\d+\b/g
                ];
                
                let foundReferences = [];
                const textToCheck = title + ' ' + body;
                
                for (const pattern of patterns) {
                  const matches = textToCheck.match(pattern);
                  if (matches) {
                    hasValidIssueReference = true;
                    foundReferences.push(...matches);
                  }
                }
                
                console.log('Fallback text parsing found:', foundReferences);
                
                if (hasValidIssueReference) {
                  core.notice(`‚úÖ Found issue references via fallback: ${foundReferences.join(', ')}`);
                  console.log('‚úÖ Issue reference found via text parsing fallback');
                }
              }
            } catch (error) {
              console.log('‚ùå Both GraphQL API and fallback failed:', error.message);
            }
            
            if (!hasValidIssueReference) {
              throw new Error(
                '‚ùå PR must reference an issue number.\n\n' +
                'Please include one of the following in your PR title or description:\n' +
                '‚Ä¢ "Fixes #123" - Automatically closes the issue when PR is merged\n' +
                '‚Ä¢ "Closes #123" - Automatically closes the issue when PR is merged\n' +
                '‚Ä¢ "Resolves #123" - Automatically closes the issue when PR is merged\n' +
                '‚Ä¢ "#123" - References the issue without auto-closing\n\n' +
                'This ensures proper issue tracking and project management.'
              );
            }

  validate-pr-format:
    runs-on: ubuntu-latest
    name: Validate PR Format
    steps:
      - name: Check PR Title Format
        uses: actions/github-script@v7
        with:
          script: |
            const title = context.payload.pull_request.title;
            
            // Êé®Â•®„Åï„Çå„ÇãPR„Çø„Ç§„Éà„É´ÂΩ¢Âºè„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            const validPrefixes = [
              'feat:', 'fix:', 'docs:', 'style:', 'refactor:', 
              'test:', 'chore:', 'ci:', 'build:', 'perf:'
            ];
            
            const hasValidPrefix = validPrefixes.some(prefix => 
              title.toLowerCase().startsWith(prefix)
            );
            
            if (!hasValidPrefix) {
              core.warning(
                '‚ö†Ô∏è Consider using conventional commit format for PR title.\n\n' +
                'Recommended formats:\n' +
                '‚Ä¢ feat: add new feature\n' +
                '‚Ä¢ fix: resolve bug\n' +
                '‚Ä¢ docs: update documentation\n' +
                '‚Ä¢ refactor: improve code structure\n' +
                '‚Ä¢ test: add or update tests\n' +
                '‚Ä¢ chore: maintenance tasks\n\n' +
                'Current title: ' + title
              );
            } else {
              console.log('‚úÖ PR title follows conventional commit format');
            }