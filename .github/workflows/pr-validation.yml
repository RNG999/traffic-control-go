name: PR Validation

on:
  pull_request:
    types: [opened, edited, synchronize]

jobs:
  validate-issue-link:
    runs-on: ubuntu-latest
    name: Validate Issue Link
    steps:
      - name: Check for Issue Reference
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            
            console.log('=== PR VALIDATION DEBUG ===');
            console.log('PR Number:', prNumber);
            
            let hasValidIssueReference = false;
            let foundIssues = [];
            
            console.log('üîç Using Timeline API for authoritative issue linking...');
            
            // Exponential Backoff„Åß„É™„Éà„É©„Ç§„Åô„Çã
            async function checkTimelineWithExponentialBackoff(maxRetries = 4, baseDelayMs = 500) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  console.log(`Timeline API attempt ${attempt}/${maxRetries}`);
                  
                  const { data: timelineEvents } = await github.rest.issues.listEventsForTimeline({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber
                  });
                  
                  console.log(`Timeline events found: ${timelineEvents.length}`);
                  
                  // „Éá„Éê„ÉÉ„Ç∞: ÂÖ®„Ç§„Éô„É≥„Éà„ÅÆË©≥Á¥∞„Çí„É≠„Ç∞
                  timelineEvents.forEach((event, index) => {
                    console.log(`Event ${index + 1}: type="${event.event}", actor="${event.actor?.login}", created="${event.created_at}"`);
                    if (event.source) {
                      console.log(`  - Source: type="${event.source.type}", issue=${!!event.source.issue}`);
                      if (event.source.issue) {
                        console.log(`  - Issue: #${event.source.issue.number} "${event.source.issue.title}"`);
                      }
                    }
                  });
                  
                  // connected/cross-referenced„Ç§„Éô„É≥„Éà„Åã„ÇâIssueÁï™Âè∑„ÇíÊäΩÂá∫
                  for (const event of timelineEvents) {
                    if ((event.event === 'connected' || event.event === 'cross-referenced') && 
                        event.source && event.source.issue) {
                      const issueNumber = event.source.issue.number;
                      foundIssues.push(issueNumber);
                      hasValidIssueReference = true;
                      console.log(`‚úÖ Found linked issue #${issueNumber} (${event.event})`);
                    }
                  }
                  
                  if (hasValidIssueReference) {
                    core.notice(`‚úÖ PR is properly linked to issues: ${foundIssues.map(n => '#' + n).join(', ')}`);
                    console.log('‚úÖ Issue reference validation passed via Timeline API');
                    return true;
                  }
                  
                  if (attempt < maxRetries) {
                    // Exponential backoff: 500ms, 1s, 2s, 4s
                    const delayMs = baseDelayMs * Math.pow(2, attempt - 1);
                    console.log(`‚è≥ No issue links found yet, waiting ${delayMs}ms (exponential backoff)...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                  }
                  
                } catch (error) {
                  console.log(`‚ùå Timeline API attempt ${attempt} failed:`, error.message);
                  if (attempt === maxRetries) {
                    throw error;
                  }
                  // API „Ç®„É©„Éº„Åß„ÇÇexponential backoff
                  const delayMs = baseDelayMs * Math.pow(2, attempt - 1);
                  console.log(`‚è≥ Retrying after ${delayMs}ms (exponential backoff)...`);
                  await new Promise(resolve => setTimeout(resolve, delayMs));
                }
              }
              return false;
            }
            
            try {
              const timelineSuccess = await checkTimelineWithExponentialBackoff();
              if (!timelineSuccess) {
                console.log('‚ö†Ô∏è Timeline API found no issue links, falling back to text parsing');
                // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „ÉÜ„Ç≠„Çπ„ÉàËß£Êûê
                const title = context.payload.pull_request.title;
                const body = context.payload.pull_request.body || '';
                
                console.log('PR Title:', title);
                console.log('PR Body length:', body.length);
                
                const patterns = [
                  /(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)\s+#\d+/gi,
                  /\B#\d+\b/g
                ];
                
                let foundReferences = [];
                const textToCheck = title + ' ' + body;
                
                for (const pattern of patterns) {
                  const matches = textToCheck.match(pattern);
                  if (matches) {
                    hasValidIssueReference = true;
                    foundReferences.push(...matches);
                  }
                }
                
                console.log('Fallback text parsing found:', foundReferences);
                
                if (hasValidIssueReference) {
                  core.notice(`‚úÖ Found issue references via fallback: ${foundReferences.join(', ')}`);
                  console.log('‚úÖ Issue reference found via text parsing fallback');
                }
              }
            } catch (error) {
              console.log('‚ùå Both Timeline API and fallback failed:', error.message);
            }
            
            if (!hasValidIssueReference) {
              throw new Error(
                '‚ùå PR must reference an issue number.\n\n' +
                'Please include one of the following in your PR title or description:\n' +
                '‚Ä¢ "Fixes #123" - Automatically closes the issue when PR is merged\n' +
                '‚Ä¢ "Closes #123" - Automatically closes the issue when PR is merged\n' +
                '‚Ä¢ "Resolves #123" - Automatically closes the issue when PR is merged\n' +
                '‚Ä¢ "#123" - References the issue without auto-closing\n\n' +
                'This ensures proper issue tracking and project management.'
              );
            }

  validate-pr-format:
    runs-on: ubuntu-latest
    name: Validate PR Format
    steps:
      - name: Check PR Title Format
        uses: actions/github-script@v7
        with:
          script: |
            const title = context.payload.pull_request.title;
            
            // Êé®Â•®„Åï„Çå„ÇãPR„Çø„Ç§„Éà„É´ÂΩ¢Âºè„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            const validPrefixes = [
              'feat:', 'fix:', 'docs:', 'style:', 'refactor:', 
              'test:', 'chore:', 'ci:', 'build:', 'perf:'
            ];
            
            const hasValidPrefix = validPrefixes.some(prefix => 
              title.toLowerCase().startsWith(prefix)
            );
            
            if (!hasValidPrefix) {
              core.warning(
                '‚ö†Ô∏è Consider using conventional commit format for PR title.\n\n' +
                'Recommended formats:\n' +
                '‚Ä¢ feat: add new feature\n' +
                '‚Ä¢ fix: resolve bug\n' +
                '‚Ä¢ docs: update documentation\n' +
                '‚Ä¢ refactor: improve code structure\n' +
                '‚Ä¢ test: add or update tests\n' +
                '‚Ä¢ chore: maintenance tasks\n\n' +
                'Current title: ' + title
              );
            } else {
              console.log('‚úÖ PR title follows conventional commit format');
            }